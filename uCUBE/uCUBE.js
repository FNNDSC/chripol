// str_aboutME     = `
//     Module and class that mimics a CUBE instance in as much
//     as returning Feed Analysis table objects.
// `

const   yargs       = require("yargs");
const   faker       = require('faker');
const   fs          = require('fs');

const   colorize    = require("json-colorizer");

const   outputbox   = require('../util/outbox.js');
const { throws }    = require('assert');
var       _         = require('lodash');

module.exports      = {

    CUBEoptions:  yargs
    .usage("Usage: [--verbose] [--man] [--generateFeedTable <noOfFeeds>] [--stateFile <stateFile>]")
    .option(
        "v", {
            alias:          "verbose",
            describe:       "If specified, be chatty",
            type:           "boolean",
            default:        false
        })
    .option(
        "F", {
            alias:          "generateNewFeedTable",
            describe:       "Create a new deep state of <noOfFeed> entries.",
            type:           "int",
            default:        0
        })
    .option(
        "S", {
            alias:          "stateFile",
            describe:       "Name of the stateFile generated by uCUBE.",
            type:           "string",
            default:        "CUBE-coreState.json"
        })
    .option(
        "m", {
            alias:          "man",
            describe:       "If specified, show a man page",
            type:           "boolean",
            default:        false
        })
    .option(
        "d", {
            alias:          "getFullDeepState",
            describe:       "If specified, show the full (deep) state of CUBE",
            type:           "boolean",
            default:        false
        })
    .option(
        "D", {
            alias:          "getDeepState",
            describe:       "If specified, show the (deep) state of CUBE with <limit>,<offset>",
            type:           "string",
            default:        ""
        })
    .option(
        "f", {
            alias:          "getFieldForID",
            describe:       "Return the <value> for <field> in feed <id>",
            type:           "string",
            default:        ""
        })
    .option(
        "a", {
            alias:          "addFeed",
            describe:       "Add a new Feed to the CUBE core state",
            type:           "boolean",
            default:        false
        })
    .option(
        "A", {
            alias:          "advanceFeed",
            describe:       "Advance parameters of <feedID> (RunTime, Size, JobsDone, JobsRunning, JobsTotal",
            type:           "string",
            default:        ""
        })
    .option(
        "p", {
            alias:          "addJobs",
            describe:       "Add new jobs to <feedID> (JobsTotal)",
            type:           "string",
            default:        ""
        })
    .argv,

    uCUBE:      function(options) {
        this.str_help       = `

        "micro"CUBE simulator. On startup generates a table of
        feeds with <totalAnalyses> rows.

        `;
        this.options        = options;
        this.jid            = 0;
        this.l_feeds        = [];
        this.error          = null;
        this.newFeedTable   = options.generateNewFeedTable;

        this.stateFile      = options.stateFile;
        this.b_stateOK      = false;
        this.b_stateSaved   = false;
        this.b_stateRead    = false;

        this.error          = null;

        this.outbox         = new outputbox.outbox(options);
        this.outbox.outputBox_setup();
    }
}

module.exports.uCUBE.prototype  = {
    constructor:    module.exports.uCUBE,

    created:        function() {
        return(faker.date.recent());
    },

    creator:        function() {
        return(faker.name.findName());
    },

    analysis:       function() {
        return(faker.animal.bird());
    },

    id:             function() {
        this.jid += 1;
        return(this.jid);
    },

    randint:        function(min, max) {
        // min and max included
        return Math.floor(Math.random() * (max - min + 1) + min);
    },

    row_generate:   function() {
        totalJobs   = this.randint(1, 10);
        doneJobs    = this.randint(1, totalJobs);
        runningJobs = this.randint(1, totalJobs - doneJobs - 1);
        runTime     = this.randint(1, 500);
        jobSize     = this.randint(1, 500);
        return ( {
            'id':           this.id(),
            'Analysis':     this.analysis(),
            'Created':      this.created().toUTCString(),
            'Creator':      this.creator(),
            'Run_Time':     runTime,
            'Size':         jobSize,
            'JobsDone':     doneJobs,
            'JobsRunning':  runningJobs,
            'JobsTotal':    totalJobs
        })
    },

    initialize:         function() {
        str_about = `
            Initialize the CUBE "instance" by either reading from an existing
            state file, or creating a new state table. If a state file does not
            exist, and if a newFeedTable size has not been specified, default to
            50.
        `;
        let b_init  = false;
        if(fs.existsSync(this.stateFile)) {
            b_init = this.feeds_stateRead();
        }
        else {
            if(!this.newFeedTable)
                this.newFeedTable   = 50;
            b_init = this.feeds_newCreate();
        }
        return(b_init);
    },

    feed_addNew:        function() {
        let d_ret   = {
            'insertFeed':   false,
            'stateSave':    false
        }
        try {
            this.l_feeds.splice(0, 0, this.row_generate());
            d_ret.insertFeed    = true;
        } catch(e) {
            this.error  = e;
            this.outputBox_print(this.info_error(), 'error');
            return d_ret;
        }
        d_ret.stateSave = this.feeds_stateSave();
        return(d_ret);
    },

    feeds_newCreate:    function() {
        let row = 0;
        for(row=0; row<this.newFeedTable; row++) {
            this.l_feeds.splice(0, 0, this.row_generate());
        }
        if(row) {
            this.b_stateOK      = true;
            this.feeds_stateSave();
        }
        else {
            this.b_stateOK      = false;
        }
        return this.b_stateOK;
    },

    feeds_stateSave:        function() {
        const data = JSON.stringify(this.l_feeds, null, 4);
        this.b_stateSaved   = false;
        try {
            fs.writeFileSync(this.stateFile, data)
            this.b_stateSaved       = true;
            this.outbox.outputBox_print("CUBE state saved to " + this.stateFile + "\n" +
                                 this.jid + " Feeds saved.");
        } catch (e) {
            this.error      = e;
            this.outbox.outputBox_print(this.info_error(), 'error');
        }
        return(this.b_stateSaved);
    },

    feeds_stateRead:            function() {
        this.b_stateRead        = false;
        let fileData            = null;
        try {
            fileData            = fs.readFileSync(this.stateFile);
            this.b_stateRead    = true
        } catch(e) {
            this.error          = e;
            this.outbox.outputBox_print(this.info_error(), 'warning');
        }
        if(this.b_stateRead) {
            this.l_feeds        = JSON.parse(fileData);
            this.jid            = this.l_feeds[0]['id'];
        }
        return(this.b_stateRead);
    },

    feeds_exist:                function() {
        let feedLength      = 0;
        let b_feedsExist    = false;
        try {
            feedLength      = this.l_feeds.length;
            b_feedsExist    = true;
        } catch(e) {
            this.CLIoutput_show("CUBE has no feeds!", comms = 'error')
        }
        return b_feedsExist;
    },

    id_exists:                  function(aid) {
        const idCheck   = (id) => id == aid;
        l_index = this.l_feeds.map(function (d_i) {
            return(d_i['id']);
        });
        return(l_index.findIndex(idCheck));
    },

    feed_advanceState:          function(feedID) {
        let index   = -1;
        d_ret       = {
            'index':        index,
            'Run_Time':     -1,
            'Size':         -1,
            'JobsDone':     -1,
            'JobsRunning':  -1,
            'JobsTotal':    -1,
            'stateSave':    false
        }
        if(this.feeds_exist()) {
            d_ret.index   = this.id_exists(feedID);
            if(d_ret.index == -1) return(d_ret);
            d_feed  = this.l_feeds[d_ret.index];
            if(d_feed.JobsDone < d_feed.JobsTotal) {
                if(d_feed.JobsRunning) {
                    let JobsJustCompleted = this.randint(1, d_feed.JobsRunning);
                    d_feed.JobsDone      += JobsJustCompleted;
                    d_feed.JobsRunning   -= JobsJustCompleted;
                    d_feed.JobsRunning    = this.randint(1, d_feed.JobsTotal - d_feed.JobsDone - 1);
                    d_feed.Run_Time      += this.randint(1, 500);
                    d_feed.Size          += this.randint(1, 500);
                    l_update              = ['Run_Time', 'Size', 'JobsDone', 'JobsRunning', 'JobsTotal'];
                    l_update.forEach(item => d_ret[item] = d_feed[item]);
                    d_ret.stateSave       = this.feeds_stateSave();
                }
            }
        }
        return(d_ret);
    },

    feed_addPlugins:            function(feedID) {
        // Add a random number of "new" plugins to a feedID
        let index   = -1;
        d_ret       = {
            'index':            index,
            'JobsTotalBefore':  -1,
            'JobsTotal':        -1,
            'stateSave':        false
        }
        if(this.feeds_exist()) {
            d_ret.index     = this.id_exists(feedID);
            if(d_ret.index == -1) return(d_ret);
            let d_feed      = this.l_feeds[d_ret.index];
            let JobsJustAdded     = this.randint(1, d_feed.JobsTotal);
            d_ret.JobsTotalBefore = d_feed.JobsTotal;
            d_feed.JobsTotal     += JobsJustAdded;
            d_ret.JobsTotal       = d_feed.JobsTotal;
            d_ret.stateSave       = this.feeds_stateSave();
        }
        return(d_ret);
    },

    getStates:                  function(params) {
        if(this.feeds_exist()) {
            let offset      = parseInt(params.offset);
            let limit       = parseInt(params.limit);
            if(offset < this.l_feeds.length) {
                if(offset + limit < this.l_feeds.length) {
                    return(this.l_feeds.slice(offset, offset+limit));
                } else {
                    return(this.l_feeds.slice(offset));
                }
            }
        }
    },

    feeds_shallowReturn:        function() {
        let str_about = `
            Return the feed list but with 'Run Time' and 'Size' set to '-'.
        `;
        let l_deepCopy_feeds  = _.cloneDeep(this.l_feeds);
        l_deepCopy_feeds.map(function (d_i) {
            d_i.Run_Time    = '-';
            d_i.Size        = '-';
            return(d_i);
        });
        return(l_deepCopy_feeds);
    },

    feed_getFieldValue:         function(aid, str_field = 'Size') {
        let str_about   = `
            For a given feed ID, return the field value specified.
        `;
        let b_getOK     = false;
        let d_ret       = {
            'status'    : b_getOK,
            'id'        : aid,
            'index'     : -1,
            'key'       : str_field,
            'value'     : ""
        }
        let index       = -1;
        if(str_field in this.l_feeds[0]) {
            index           = this.id_exists(aid);
            if(index == -1) return d_ret;
            d_ret.status    = true;
            d_ret.index     = index;
            d_ret.key       = str_field;
            d_ret.value     = this.l_feeds[index][str_field];
            return(d_ret);
        }
    },

    CLIoutput_show:          function(str_data, comms = 'normal') {
        this.outbox.outputBox_print(str_data, comms);
    },

    info_error:             function() {
        str_info        = `
ERROR!

${this.error}
        `;
        return(str_info);
    },

}
